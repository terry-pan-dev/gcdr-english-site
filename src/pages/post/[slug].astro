---
export const prerender = false;

import BlogLayout from "../../layouts/BlogLayout.astro";
import { BlogNavigation } from "../../components/BlogNavigation";
import { marked } from "marked";

// Configure marked for GFM features (same as admin preview)
marked.setOptions({
  gfm: true,
  breaks: false,
});

const { slug } = Astro.params;

// Get API base URL from environment - handle both build-time and runtime
const apiBaseUrl = process.env.PUBLIC_API_BASE_URL || import.meta.env.PUBLIC_API_BASE_URL || "";

// Debug: Log the API URL
console.log("API Base URL:", apiBaseUrl);
console.log("Slug:", slug);

// Fetch blog post from public API (which has S3 access)
let post: any = null;
let blogContent = "";
let fetchError = "";

// Only fetch if we have a valid API URL
if (apiBaseUrl) {
  try {
    const fetchUrl = `${apiBaseUrl}/api/public/blogs/${slug}`;
    console.log("Fetching from:", fetchUrl);

    // Fetch single blog with content from public API
    const response = await fetch(fetchUrl);
    console.log("Response status:", response.status);

    if (response.ok) {
      const blogData = await response.json();

      if (blogData && blogData.publish) {
        // Check if blog date is in the past
        const postDate = new Date(blogData.date);
        postDate.setHours(0, 0, 0, 0);
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        if (postDate <= today) {
          // Convert markdown to HTML (same as admin preview uses marked)
          const rawContent = blogData.content || "";
          blogContent = marked.parse(rawContent) as string;

          // Convert to post format compatible with BlogLayout
          post = {
            id: blogData.id,
            data: {
              title: blogData.title,
              date: new Date(blogData.date),
              author: blogData.author,
              category: blogData.category,
              excerpt: blogData.excerpt,
              image: blogData.image,
              featured: blogData.featured,
              pinned: blogData.pinned,
              tags: blogData.tags || [],
              publish: blogData.publish,
              seo: blogData.seo,
            },
            body: blogContent,
            slug: blogData.id,
          };
        }
      }
    } else {
      fetchError = `API returned ${response.status}`;
    }
  } catch (error) {
    console.error("Error fetching blog from API:", error);
    fetchError = String(error);
  }
} else {
  fetchError = "No API URL configured";
}

if (!post) {
  // Instead of redirecting, show an error page so we can debug
  return new Response(
    `<!DOCTYPE html>
<html>
<head><title>Blog Error</title></head>
<body>
<h1>Blog Post Not Found</h1>
<p>Slug: ${slug}</p>
<p>API URL: ${apiBaseUrl || "(not set)"}</p>
<p>Error: ${fetchError || "Post not found or not published"}</p>
<p><a href="/blog">Back to Blog</a></p>
</body>
</html>`,
    {
      status: 404,
      headers: { "Content-Type": "text/html" },
    }
  );
}

// Get all published posts for navigation from public API
let allPublishedPosts: any[] = [];
try {
  const listResponse = await fetch(`${apiBaseUrl}/api/public/blogs`);
  if (listResponse.ok) {
    const listData = await listResponse.json();
    const blogs = listData.blogs || [];

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    allPublishedPosts = blogs
      .filter((blog: any) => {
        if (!blog.publish) return false;
        const pDate = new Date(blog.date);
        pDate.setHours(0, 0, 0, 0);
        return pDate <= today;
      })
      .map((blog: any) => ({
        id: blog.id,
        data: {
          title: blog.title,
          date: new Date(blog.date),
          author: blog.author,
          category: blog.category,
          excerpt: blog.excerpt,
          image: blog.image,
          featured: blog.featured,
          pinned: blog.pinned,
          tags: blog.tags || [],
          publish: blog.publish,
          seo: blog.seo,
        },
      }));
  }
} catch (error) {
  console.warn("Could not fetch blogs for navigation:", error);
}

// Sort posts: pinned first, then by date (newest first)
const sortedPosts = allPublishedPosts.sort((a, b) => {
  const aPinned = a.data.pinned ?? false;
  const bPinned = b.data.pinned ?? false;
  if (aPinned !== bPinned) {
    return bPinned ? 1 : -1;
  }
  return new Date(b.data.date).getTime() - new Date(a.data.date).getTime();
});

// Find current post index
const currentIndex = sortedPosts.findIndex((p) => p.id === post.id);
const previousPost = currentIndex > 0 ? sortedPosts[currentIndex - 1] : null;
const nextPost = currentIndex < sortedPosts.length - 1 ? sortedPosts[currentIndex + 1] : null;
---

<BlogLayout post={post}>
  <Fragment set:html={blogContent} />
  <BlogNavigation previousPost={previousPost} nextPost={nextPost} client:load />
</BlogLayout>
