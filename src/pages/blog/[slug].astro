---
export const prerender = false;

import BlogLayout from "../../layouts/BlogLayout.astro";
import { BlogNavigation } from "../../components/BlogNavigation";
import { getS3Blogs } from "../../lib/server-blog-api";
import { S3Client, GetObjectCommand } from "@aws-sdk/client-s3";

const { slug } = Astro.params;

// Fetch S3-based post (remote only)
let post: any = null;
let s3Content = "";

try {
  const s3Blogs = await getS3Blogs();
  const s3Post = s3Blogs.find((blog) => blog.id === slug);
  
  if (s3Post) {
    // Fetch content from S3
    const s3Client = new S3Client({});
    const bucketName = process.env.BLOG_STORAGE_BUCKET;
    
    if (bucketName && s3Post.s3Key) {
      try {
        const s3Command = new GetObjectCommand({
          Bucket: bucketName,
          Key: s3Post.s3Key,
        });
        const s3Result = await s3Client.send(s3Command);
        s3Content = await s3Result.Body?.transformToString() || "";
        
        // Convert to post format compatible with BlogLayout
        post = {
          id: s3Post.id,
          data: {
            title: s3Post.title,
            date: new Date(s3Post.date),
            author: s3Post.author,
            category: s3Post.category,
            excerpt: s3Post.excerpt,
            image: s3Post.image,
            featured: s3Post.featured,
            pinned: s3Post.pinned,
            tags: s3Post.tags,
            publish: s3Post.publish,
            seo: s3Post.seo,
          },
          body: s3Content,
          slug: s3Post.id,
        };
      } catch (s3Error) {
        console.error("Error fetching S3 content:", s3Error);
      }
    }
  }
} catch (error) {
  console.warn("Could not fetch S3 blogs:", error);
}

if (!post) {
  return Astro.redirect("/blog");
}

// Check if post is published and date has arrived
const isPublished = post.data.publish ?? true;
if (!isPublished) {
  return Astro.redirect("/blog");
}

const now = new Date();
const postDate = new Date(post.data.date);
postDate.setHours(0, 0, 0, 0);
const today = new Date(now);
today.setHours(0, 0, 0, 0);

if (postDate > today) {
  return Astro.redirect("/blog");
}

// Get all published posts for navigation (S3-based only)
let s3Posts: any[] = [];
try {
  const s3Blogs = await getS3Blogs();
  s3Posts = s3Blogs.map((blog) => ({
    id: blog.id,
    data: {
      title: blog.title,
      date: new Date(blog.date),
      author: blog.author,
      category: blog.category,
      excerpt: blog.excerpt,
      image: blog.image,
      featured: blog.featured,
      pinned: blog.pinned,
      tags: blog.tags,
      publish: blog.publish,
      seo: blog.seo,
    },
  }));
} catch (error) {
  console.warn("Could not fetch S3 blogs for navigation:", error);
}
const allPosts = s3Posts;
const publishedPosts = allPosts.filter((p) => {
  const isPub = p.data.publish ?? true;
  if (!isPub) return false;

  const pDate = new Date(p.data.date);
  pDate.setHours(0, 0, 0, 0);
  return pDate <= today;
});

// Sort posts: pinned first, then by date (newest first)
const sortedPosts = publishedPosts.sort((a, b) => {
  const aPinned = a.data.pinned ?? false;
  const bPinned = b.data.pinned ?? false;
  if (aPinned !== bPinned) {
    return bPinned ? 1 : -1;
  }
  return new Date(b.data.date).getTime() - new Date(a.data.date).getTime();
});

// Find current post index
const currentIndex = sortedPosts.findIndex((p) => p.id === post.id);
const previousPost = currentIndex > 0 ? sortedPosts[currentIndex - 1] : null;
const nextPost =
  currentIndex < sortedPosts.length - 1 ? sortedPosts[currentIndex + 1] : null;
---

<BlogLayout post={post}>
  <div class="prose prose-lg prose-stone max-w-none" set:html={s3Content} />
  <BlogNavigation previousPost={previousPost} nextPost={nextPost} client:load />
</BlogLayout>
